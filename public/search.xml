<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubutu桌面不显示</title>
    <url>/posts/c66da4c6/</url>
    <content><![CDATA[<h2><span id="ubuntu-桌面不显示文件">ubuntu 桌面不显示文件</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">win + tab</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2><span id="ubuntu-输入法间隔变大">ubuntu 输入法间隔变大</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">shift + space</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署在gitee可能出现问题</title>
    <url>/posts/5237292d/</url>
    <content><![CDATA[<h2><span id="gitee-静态页面强制">gitee  静态页面强制</span></h2><a id="more"></a>

<p>将hexo部署到gitee后，本地可以更新，浏览器访问必须强制刷新,清除浏览器缓存后更新，否则一直调用本地缓存，并且第一次登入图标加载也会有点问题。</p>
<p><strong>将hexo部署到github并未发生这种问题</strong></p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>-gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题历程</title>
    <url>/posts/d16ecfb3/</url>
    <content><![CDATA[<p>#以C++作为编程语言刷题，开始并未使用STL，感觉设计运行确实繁琐一些</p>
<a id="more"></a>
<h2><span id="剑指offer-03-数组重复数字">剑指offer 03 数组重复数字</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"> for(int i&#x3D;0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int index&#x3D;nums[i]%nums.size();</span><br><span class="line">        nums[index]+&#x3D;nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]&gt;&#x3D;2*nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">## 剑指offer 04 二位数组查找</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    bool findNumberIn2DArray(vector&lt;vector<int>&gt;&amp; matrix, int target) {<br>         if ( matrix.size() == 0 || matrix[0].size() == 0) {<br>            return false;<br>        }</int></p>
<pre><code>    int rows = matrix.size(), coums = matrix[0].size();
    int coum = coums - 1;
    int row = 0;
    while(row&lt;rows&amp;&amp;coum&gt;=0)
    &#123;
        if(target == matrix[row][coum])
        &#123;
            return true;
        &#125;
        else if (target &lt; matrix[row][coum])
        &#123;
            coum--;
        &#125;

        else
        &#123;
            row++;
        &#125;
    &#125;


    return false;
&#125;</code></pre>
<p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 剑指offer 05 替换空格</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    string replaceSpace(string s) {</p>
<pre><code>   string str = &quot;%20&quot;;
   while((-1)!=s.find(&#39; &#39;) )
   &#123;
       s.replace(s.find(&#39; &#39;),1,str);

   &#125;

    return s;
&#125;</code></pre>
<p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 剑指offer 06 打印链表</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li><p>Definition for singly-linked list.</p>
</li>
<li><p>struct ListNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>ListNode *next;</p>
</li>
<li><p>ListNode(int x) : val(x), next(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  vector<int> reversePrint(ListNode* head) {</int></p>
<p>  vector<int> p;<br>  while(head)<br>  {</int></p>
<pre><code>  p.push_back(head-&gt;val);
  head = head-&gt;next;</code></pre>
<p>  }</p>
<p>  vector<int> m;<br>  int j;<br>  for(j=p.size()-1; j &gt;=0;j– )<br>  {</int></p>
<pre><code>  //cout &lt;&lt; p[j] &lt;&lt; endl;
  m.push_back(p[j]);</code></pre>
<p>  }</p>
<p>  return m;</p>
</li>
</ul>
<pre><code>&#125;</code></pre>
<p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 剑指offer 07 重建二叉树</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li><p>Definition for a binary tree node.</p>
</li>
<li><p>struct TreeNode {</p>
</li>
<li><p>int val;</p>
</li>
<li><p>TreeNode *left;</p>
</li>
<li><p>TreeNode *right;</p>
</li>
<li><p>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
</li>
<li><p>};</p>
</li>
<li><p>/<br>class Solution {<br>public:<br>  TreeNode* buildTree(vector<int>&amp; preorder, vector<int>&amp; inorder) {</int></int></p>
<pre><code>  if(preorder.empty() || preorder.size() != inorder.size()) return nullptr;
  int preStart = 0, inStart = 0;
  int preEnd = preorder.size() - 1, inEnd = inorder.size() - 1;

  return binaryTree(preorder, inorder, preStart, preEnd, inStart, inEnd);</code></pre>
<p>  }</p>
<p>  TreeNode *binaryTree(vector<int>&amp; preorder, vector<int>&amp; inorder, int preStart, int preEnd, int inStart, int inEnd)<br>  {</int></int></p>
<pre><code>  if(preStart &gt; preEnd || inStart &gt; inEnd) return nullptr;
  TreeNode *root = new TreeNode(preorder[preStart]);
  int middle = 0;
  for(auto i : inorder)
  &#123;
      if(i != preorder[preStart]) middle ++;
      else break;
  &#125;
  root -&gt; left = binaryTree(preorder, inorder, preStart+1, preStart+middle-inStart, inStart, middle-1);
  root -&gt; right = binaryTree(preorder, inorder, preEnd-(inEnd-middle)+1, preEnd, middle+1, inEnd);
  return root;</code></pre>
</li>
</ul>
<pre><code>&#125;</code></pre>
<p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 1592 重新排列2单词间空格</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    string reorderSpaces(string text) {</p>
<pre><code>using namespace  std;


int num = 0;


int sum = text.length();  






string str_out = &quot;&quot;;
int jishu[100] = &#123;0&#125;;
string str;
int flag = text.find(&#39; &#39;);

int i = 1;

  while((-1) != flag)
&#123;


    while(0 == flag)
    &#123;
        text.erase(0, 1);

        flag = text.find(&#39; &#39;);
        if(text.length() &gt; 0)
        &#123;
            jishu[i] = text.length();
        &#125;
    &#125;



    if (flag &gt; 0 )
    &#123;

        str = text.substr(0, flag);
        jishu[i] = flag;
        str_out += str;
        text.erase(0, flag);
        i += 1;
        flag = text.find(&#39; &#39;);
    &#125;

        else
        &#123;
           break;
        &#125;






    &#125;



int j = 1;
for (j=1; j&lt;=i; j++)
&#123;


    if(jishu[j] &gt; 0)
    &#123;
    num += jishu[j];
    &#125;


&#125;



int n_s = sum - num;


if( i &gt; 1)
&#123;

int sp , rsp;


if(0 == text.length())
&#123;
    n_s = sum -str_out.length() ;
    int n =str_out.length()- jishu[i-1];
    text = str_out.substr(n, jishu[i-1]);
    i -= 1;
    if(i == 1)
    &#123;
        rsp = sum - jishu[1] ;
        string space = &quot;&quot;;
        space.append(rsp, &#39; &#39;);
        str_out += space;
        return str_out;
    &#125;
    else
    &#123;

      cout  &lt;&lt; &quot;@&quot; &lt;&lt; str_out.length() &lt;&lt; &quot;@&quot; &lt;&lt; i &lt;&lt; endl;
       sp = n_s/(i-1) ;

       rsp = n_s -sp *(i-1);
    &#125;
&#125;
else
&#123;

   sp = n_s/(i-1);

    rsp = n_s -sp *(i-1);
&#125;










int s;
string  space = &quot;&quot; ;
space.append(sp, &#39; &#39;);
string  rspace = &quot;&quot; ;
rspace.append(rsp, &#39; &#39;);


  string retu = &quot;&quot;;


for (s =1; s&lt; i ; s++)
&#123;



    retu += str_out.substr(0, jishu[s]) +  space;

    str_out.erase(0, jishu[s]);



&#125;


 retu += text ;

 retu += rspace ; 

 return retu;


&#125;</code></pre>
<p>else<br>{</p>
<p>   int rsp = sum - text.length();<br>   string rspace = “”;<br>   rspace.append(rsp, ‘ ‘);<br>   text += rspace;<br>   return text;</p>
<p>}<br>    }<br>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 1630 等差子数组</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    vector<bool> checkArithmeticSubarrays(vector<int>&amp; nums, vector<int>&amp; l, vector<int>&amp; r) {<br>        using namespace std;<br>        int num_l = l.size();<br>        vector<bool> answer;<br>        vector<int> p;<br>        int length,n,j, loss;<br>        int  idea =0;<br>        for (int i=0; i&lt;num_l; i++)<br>        {<br>            for ( j=l[i]; j&lt;=r[i]; j++)<br>            {</int></bool></int></int></int></bool></p>
<pre><code>            p.push_back(nums[j]);
           // cout &lt;&lt; nums[j] &lt;&lt; endl;

        &#125;

        sort(p.begin(), p.end());
        length = p.size();
         loss =abs( p[1] - p[0]);

        for ( n=1; n&lt;length; n++)
        &#123;
            if (p[n] != (p[n-1]+loss))
            &#123;
                answer.push_back(false);
                idea += 1;
                break;
            &#125;

        &#125;

    if (idea == i)
    &#123;
        answer.push_back(true);
        idea += 1;
    &#125;

        p.clear();

    &#125;


    return answer;
&#125; </code></pre>
<p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 1629 按键持续最长的建</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    char slowestKey(vector<int>&amp; releaseTimes, string keysPressed) {</int></p>
<pre><code>    int n = releaseTimes.size();

    int num = 0;
    int time;
    int time_max = 0;

    for(int i=0; i&lt;n; i++)
    &#123;
        if (i &gt;0)
            time = releaseTimes[i] -  releaseTimes[i-1];
        else
            time = releaseTimes[i] ;
        if (time &gt;= time_max)
        &#123;
            time_max  =  time;
            num = i;
        &#125;       
    &#125;
    return keysPressed[num];
&#125;</code></pre>
<p>};</p>
<pre><code>








</code></pre>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>letnet_minst</title>
    <url>/posts/574630c2/</url>
    <content><![CDATA[<p>lenet 在minst数据集的测试，主要增加了线性层归一化，测试集准确率为99.1%</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line">import torch.optim as optim</span><br><span class="line">from torchvision import datasets,transforms</span><br><span class="line">import torchvision</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.style.use(&#39;seaborn-white&#39;)</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;Noto Sans CJK JP&#39;] # 用来正常显示中文标签</span><br><span class="line">plt.rcParams[&#39;axes.unicode_minus&#39;]&#x3D;False # 用来正常显示负号</span><br><span class="line"></span><br><span class="line">train_acclist &#x3D; []</span><br><span class="line">test_acclist &#x3D; []</span><br><span class="line">loss_list &#x3D; []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LeNet(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(LeNet, self).__init__()</span><br><span class="line">        self.conv1 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Conv2d(1, 6, 3, 1, 2),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.conv2 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Conv2d(6, 16, 5),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc1 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(16 * 5 * 5, 120),</span><br><span class="line">            nn.BatchNorm1d(120),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc2 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(120, 84),</span><br><span class="line">            nn.BatchNorm1d(84),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc3 &#x3D; nn.Linear(84, 10)</span><br><span class="line"></span><br><span class="line">    #         self.sfx &#x3D; nn.Softmax()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x &#x3D; self.conv1(x)</span><br><span class="line">        x &#x3D; self.conv2(x)</span><br><span class="line">        #         print(x.shape)</span><br><span class="line">        x &#x3D; x.view(x.size()[0], -1)</span><br><span class="line">        x &#x3D; self.fc1(x)</span><br><span class="line">        x &#x3D; self.fc2(x)</span><br><span class="line">        x &#x3D; self.fc3(x)</span><br><span class="line">        #         x &#x3D; self.sfx(x)</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">device &#x3D; torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)</span><br><span class="line">batch_size &#x3D; 64</span><br><span class="line">LR &#x3D; 0.001</span><br><span class="line">Momentum &#x3D; 0.9</span><br><span class="line"></span><br><span class="line"># 下载数据集</span><br><span class="line">train_dataset &#x3D; datasets.MNIST(root &#x3D; &#39;&#x2F;home&#x2F;liyou&#x2F;my tools&#x2F;myworks&#39;,</span><br><span class="line">                              train&#x3D;True,</span><br><span class="line">                              transform &#x3D; transforms.ToTensor(),</span><br><span class="line">                              download&#x3D;True)</span><br><span class="line">test_dataset &#x3D;datasets.MNIST(root &#x3D; &#39;&#x2F;home&#x2F;liyou&#x2F;my tools&#x2F;myworks&#x2F;&#39;,</span><br><span class="line">                            train&#x3D;False,</span><br><span class="line">                            transform&#x3D;transforms.ToTensor(),</span><br><span class="line">                            download&#x3D;True)</span><br><span class="line">#建立一个数据迭代器</span><br><span class="line">train_loader &#x3D; torch.utils.data.DataLoader(dataset &#x3D; train_dataset,</span><br><span class="line">                                          batch_size &#x3D; batch_size,</span><br><span class="line">                                          shuffle &#x3D; True)</span><br><span class="line">test_loader &#x3D; torch.utils.data.DataLoader(dataset &#x3D; test_dataset,</span><br><span class="line">                                         batch_size &#x3D; batch_size,</span><br><span class="line">                                         shuffle &#x3D; False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def evaluate_accuracy(data_iter, net, device&#x3D;None):</span><br><span class="line">    if device is None and isinstance(net, torch.nn.Module):</span><br><span class="line">        # 如果没指定device就使用net的device</span><br><span class="line">        device &#x3D; list(net.parameters())[0].device</span><br><span class="line">    acc_sum, n &#x3D; 0.0, 0</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        for X, y in data_iter:</span><br><span class="line">            X &#x3D; X.to(device)</span><br><span class="line">            y &#x3D; y.to(device)</span><br><span class="line">            if isinstance(net, torch.nn.Module):</span><br><span class="line">                net.eval() # 评估模式, 这会关闭dropout</span><br><span class="line">                acc_sum +&#x3D; (net(X).argmax(dim&#x3D;1) &#x3D;&#x3D; y).float().sum().cpu().item()</span><br><span class="line">                net.train() # 改回训练模式</span><br><span class="line">            n +&#x3D; y.shape[0]</span><br><span class="line">    return acc_sum &#x2F; n</span><br><span class="line"></span><br><span class="line">def train_lenet(num_epochs, net, optimizer):</span><br><span class="line">    net &#x3D; net.to(device)</span><br><span class="line">    print(&quot;training on &quot;, device)</span><br><span class="line">    loss &#x3D; torch.nn.CrossEntropyLoss()</span><br><span class="line">    for epoch in range(num_epochs):</span><br><span class="line">        train_l_sum, train_acc_sum, n, batch_count, start &#x3D; 0.0, 0.0, 0, 0, time.time()</span><br><span class="line">        for X, y in train_loader:</span><br><span class="line">            X &#x3D; X.to(device)</span><br><span class="line">            y &#x3D; y.to(device)</span><br><span class="line">            y_hat &#x3D; net(X)</span><br><span class="line">            l &#x3D; loss(y_hat, y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            train_l_sum +&#x3D; l.cpu().item()</span><br><span class="line">            train_acc_sum +&#x3D; (y_hat.argmax(dim&#x3D;1) &#x3D;&#x3D; y).sum().cpu().item()</span><br><span class="line">            n +&#x3D; y.shape[0]</span><br><span class="line">            batch_count +&#x3D; 1</span><br><span class="line">        test_acc &#x3D; evaluate_accuracy(test_loader, net)</span><br><span class="line">        print(&#39;epoch %d, loss %.4f, train acc %.3f, test acc %.3f, time %.1f sec&#39;</span><br><span class="line">                % (epoch + 1, train_l_sum &#x2F; batch_count, train_acc_sum &#x2F; n, test_acc, time.time() - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        loss_list.append(train_l_sum &#x2F; batch_count)</span><br><span class="line">        train_acclist.append(train_acc_sum &#x2F; n)</span><br><span class="line">        test_acclist.append(test_acc)</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    net &#x3D; LeNet().to(device)</span><br><span class="line">    optimizer &#x3D; optim.SGD(net.parameters(),lr&#x3D;LR,momentum&#x3D;Momentum)</span><br><span class="line">    epoch &#x3D; 50</span><br><span class="line"></span><br><span class="line">    train_lenet(epoch, net, optimizer)</span><br><span class="line">    x &#x3D; np.arange(epoch)</span><br><span class="line">    fig, ax &#x3D; plt.subplots(1, 3,figsize &#x3D; (16, 3))</span><br><span class="line">  </span><br><span class="line">    ax[0].plot(x, loss_list)</span><br><span class="line">    ax[0].set_title(&quot;loss&quot;)</span><br><span class="line">    ax[1].plot(x, train_acclist)</span><br><span class="line">    ax[1].set_title(u&quot;训练集准确性&quot;)</span><br><span class="line"></span><br><span class="line">    ax[2].plot(x, test_acclist)</span><br><span class="line">    ax[2].set_title(u&quot;测试集准确性&quot;)</span><br><span class="line">    plt.savefig(&#39;.&#x2F;image&#x2F;image_m&#39;)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # x, y &#x3D; train_dataset[0]</span><br><span class="line">    # print(x.size())</span><br><span class="line">    # print(y)</span><br><span class="line"></span><br><span class="line">    # for i in range(10):</span><br><span class="line">    #       image_array,_&#x3D;train_dataset[i]#打印第i个</span><br><span class="line">    #       image_array&#x3D;image_array.resize(28,28)</span><br><span class="line">     </span><br><span class="line">    #       print(train_dataset.train_labels[i])#打印出标签</span><br><span class="line">    #       plt.imshow(image_array)</span><br><span class="line">    #       plt.savefig(&#39;.&#x2F;image&#x2F;image[%d]&#39;%(i))</span><br><span class="line">    #       plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>mylife</title>
    <url>/posts/c9e3de7b/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pthread多线程矩阵运算</title>
    <url>/posts/12c87f1c/</url>
    <content><![CDATA[<h2><span id="多线程进行矩阵运算">多线程进行矩阵运算</span></h2><p>主要为定义二级指针，实现动态二位数组以及随机赋值，但是存在线程数组无法动态赋值的问题</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;chrono&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace chrono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_mutex_t  g_mutex_lock;</span><br><span class="line">int l &#x3D; 0;</span><br><span class="line">int arry_num[4] &#x3D; &#123;48, 128,1024, 2024&#125;;</span><br><span class="line">int threads_num[4] &#x3D; &#123;1, 2, 4, 8 &#125;;</span><br><span class="line">int threads &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> unsigned long timer;</span><br><span class="line"></span><br><span class="line">int **a                                                                      ;</span><br><span class="line">int **b;</span><br><span class="line">int **c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void arry_fuzhi();</span><br><span class="line">void * THread(void * data);</span><br><span class="line">void threads_j(int j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> for(int i&#x3D;0; i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l &#x3D; arry_num[i];</span><br><span class="line">        arry_fuzhi(); </span><br><span class="line">         for (int j&#x3D; 0; j&lt;4;j++)</span><br><span class="line">            threads_j(threads_num[3]);</span><br><span class="line">           </span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    delete [] a;</span><br><span class="line">    delete [] b;</span><br><span class="line">    delete [] c;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi()</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; new int * [l];</span><br><span class="line">    b &#x3D; new int * [l];                                                          </span><br><span class="line">    c &#x3D; new int * [l];</span><br><span class="line">    for (int i&#x3D;0; i&lt;l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] &#x3D; new int[l];</span><br><span class="line">        b[i] &#x3D; new int[l];</span><br><span class="line">        c[i] &#x3D; new int[l];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int n&#x3D;0; n&lt;l; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m&#x3D;0; m&lt;l; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n][m] &#x3D; rand() % 100;</span><br><span class="line">            b[n][m] &#x3D; rand() % 100;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * THread(void *data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int i, j, k, tid, portin_size, row_start, row_end;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    tid &#x3D; *(int *)data ;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    portin_size &#x3D; l &#x2F; threads;</span><br><span class="line">    row_start &#x3D; tid * portin_size;</span><br><span class="line">    </span><br><span class="line">    row_end &#x3D; (tid+1) * portin_size;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;row_start; i&lt;row_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       for (int k&#x3D;0; k&lt;l; k++)</span><br><span class="line">       &#123;</span><br><span class="line">        for(int j&#x3D;0; j&lt;l; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i][j] * b[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        c[i][k] &#x3D; sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void threads_j(int j)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; timeval  start_t;</span><br><span class="line">            &#x2F;&#x2F; timeval  end_t;</span><br><span class="line">            timeval  start;</span><br><span class="line">            timeval  end;</span><br><span class="line">            threads &#x3D; j;</span><br><span class="line">            &#x2F;&#x2F;gettimeofday(&amp;start_t, NULL);</span><br><span class="line">            gettimeofday(&amp;start, NULL);</span><br><span class="line">            pthread_t  *pid  &#x3D; new pthread_t [j];</span><br><span class="line"></span><br><span class="line">            for(int num&#x3D;0; num&lt;j; num++)</span><br><span class="line">            &#123;</span><br><span class="line">            pthread_create(&amp;pid[num], NULL, THread,  &amp;num);</span><br><span class="line">            pthread_join(pid[num], NULL);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">           &#x2F;&#x2F; gettimeofday(&amp;end_t, NULL);</span><br><span class="line">            gettimeofday(&amp;end, NULL);</span><br><span class="line">           &#x2F;&#x2F; timer &#x3D; 1000000*(end_t.tv_sec-start_t.tv_sec)+ end_t.tv_usec-start_t.tv_usec;&#x2F;&#x2F;微秒计时</span><br><span class="line">            &#x2F;&#x2F;cout &lt;&lt;  double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den  &lt;&lt; endl;</span><br><span class="line">            timer &#x3D;1000000* (end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec;&#x2F;&#x2F;多线程计算时间（微秒）</span><br><span class="line">             cout &lt;&lt; &quot;线程设为:&quot; &lt;&lt;  endl;</span><br><span class="line">             cout  &lt;&lt;  &quot;多线程完成矩阵运算的时间为：&quot;  ; </span><br><span class="line">             cout &lt;&lt;timer &lt;&lt;  &quot;微秒&quot;  &lt;&lt; endl;</span><br><span class="line">            delete [] pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高性能</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程矩阵运算</title>
    <url>/posts/dd0dc916/</url>
    <content><![CDATA[<p>多线程矩阵运算</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;chrono&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace chrono;</span><br><span class="line"> int  l &#x3D; 0;</span><br><span class="line"> int threads_j &#x3D; 4;</span><br><span class="line">  double t;</span><br><span class="line">int arry_num[4] &#x3D; &#123;128, 256, 512, 1024&#125;;</span><br><span class="line">int **a ;</span><br><span class="line">int **b;</span><br><span class="line">int **c;</span><br><span class="line"></span><br><span class="line">void singel_worker();</span><br><span class="line">pthread_t  *pid ;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi();</span><br><span class="line">void * THread(void * data);</span><br><span class="line">void threads_time();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int a_num&#x3D;0; a_num&lt;4; a_num++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        l &#x3D; arry_num[a_num];</span><br><span class="line">        arry_fuzhi();</span><br><span class="line">        cout &lt;&lt; &quot;\n矩阵阶数：&quot; &lt;&lt; l &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        auto start1 &#x3D; system_clock::now();</span><br><span class="line">        singel_worker();</span><br><span class="line">        auto end1 &#x3D; system_clock::now();</span><br><span class="line"></span><br><span class="line">        auto duration1 &#x3D; duration_cast&lt;microseconds&gt;(end1 - start1);</span><br><span class="line">         t &#x3D; double(duration1.count()) * microseconds::period::num &#x2F; microseconds::period::den;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; &quot;单线程花费了: &quot; &lt;&lt;  t  &lt;&lt; &quot;秒&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        while (threads_j &lt; 17)</span><br><span class="line">        &#123;</span><br><span class="line">           threads_time();</span><br><span class="line">            threads_j +&#x3D; 4;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        threads_j &#x3D; 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete [] a;</span><br><span class="line">    delete [] b;</span><br><span class="line">    delete [] c;</span><br><span class="line">    delete [] pid;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi()</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; new int * [l];</span><br><span class="line">    b &#x3D; new int * [l];                                                          </span><br><span class="line">    c &#x3D; new int * [l];</span><br><span class="line">    for (int i&#x3D;0; i&lt;l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] &#x3D; new int[l];</span><br><span class="line">        b[i] &#x3D; new int[l];</span><br><span class="line">        c[i] &#x3D; new int[l];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   for (int n&#x3D;0; n&lt;l; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m&#x3D;0; m&lt;l; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n][m] &#x3D; double(rand()%100);</span><br><span class="line">            b[n][m] &#x3D; double(rand()%100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * THread(void *data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int i, j, k, tid, portin_size, row_start, row_end;</span><br><span class="line">    double  sum &#x3D; 0;</span><br><span class="line">    tid &#x3D; *(int *)data ;</span><br><span class="line"> </span><br><span class="line">    portin_size &#x3D; l &#x2F; threads_j;</span><br><span class="line">    row_start &#x3D; tid * portin_size;</span><br><span class="line">    </span><br><span class="line">    row_end &#x3D; (tid+1) * portin_size;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;row_start; i&lt;row_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       for (int k&#x3D;0; k&lt;l; k++)</span><br><span class="line">       &#123;</span><br><span class="line">        for(int j&#x3D;0; j&lt;l; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i][j] * b[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        c[i][k] &#x3D; sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void singel_worker() &#123;</span><br><span class="line">    double sum;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; l; ++i)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; l; ++j) &#123;  &#x2F;&#x2F; hold column index of &#39;matrix2&#39;</span><br><span class="line">            sum &#x3D; 0;                  &#x2F;&#x2F; hold value of a cell</span><br><span class="line">            for (int k &#x3D; 0; k &lt; l; ++k) &#123;</span><br><span class="line">                sum +&#x3D; a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">           c[i][j] &#x3D; sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threads_time()&#123;</span><br><span class="line">           int num_pth;</span><br><span class="line">            auto start &#x3D; system_clock::now();</span><br><span class="line">            pid &#x3D; new pthread_t[threads_j];</span><br><span class="line"></span><br><span class="line">            for (num_pth &#x3D; 0; num_pth &lt; threads_j; num_pth++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                pthread_create(&amp;pid[num_pth], NULL, THread, &amp;num_pth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (num_pth &#x3D; 0; num_pth &lt; threads_j; num_pth++)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_join(pid[num_pth], NULL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            auto end &#x3D; system_clock::now();</span><br><span class="line">            auto duration &#x3D; duration_cast&lt;microseconds&gt;(end - start);</span><br><span class="line">            double t1 &#x3D; double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den;</span><br><span class="line">            double  tt &#x3D; t&#x2F;t1;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; &quot;多线程设为: &quot; &lt;&lt; threads_j &lt;&lt;  &quot;线程&quot; &lt;&lt;  endl;</span><br><span class="line">            cout &lt;&lt; &quot;花费了&quot;</span><br><span class="line">                 &lt;&lt; double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den</span><br><span class="line">                 &lt;&lt; &quot;秒&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; &quot;加速比为：&quot; &lt;&lt;  tt   &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>多线程矩阵运算</tag>
      </tags>
  </entry>
</search>
