<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubutu桌面不显示</title>
    <url>/posts/c66da4c6/</url>
    <content><![CDATA[<h2 id="ubuntu-桌面不显示文件"><a href="#ubuntu-桌面不显示文件" class="headerlink" title="ubuntu 桌面不显示文件"></a>ubuntu 桌面不显示文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">win + tab</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="ubuntu-输入法间隔变大"><a href="#ubuntu-输入法间隔变大" class="headerlink" title="ubuntu 输入法间隔变大"></a>ubuntu 输入法间隔变大</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">shift + space</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署在gitee可能出现问题</title>
    <url>/posts/5237292d/</url>
    <content><![CDATA[<h2 id="gitee-静态页面强制"><a href="#gitee-静态页面强制" class="headerlink" title="gitee  静态页面强制"></a>gitee  静态页面强制</h2><a id="more"></a>

<p>将hexo部署到gitee后，本地可以更新，浏览器访问必须强制刷新,清除浏览器缓存后更新，否则一直调用本地缓存，并且第一次登入图标加载也会有点问题。</p>
<p><strong>将hexo部署到github并未发生这种问题</strong></p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>-gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题历程</title>
    <url>/posts/d16ecfb3/</url>
    <content><![CDATA[<h2 id="剑指offer-03-数组重复数字"><a href="#剑指offer-03-数组重复数字" class="headerlink" title="剑指offer 03 数组重复数字"></a>剑指offer 03 数组重复数字</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"> for(int i&#x3D;0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int index&#x3D;nums[i]%nums.size();</span><br><span class="line">        nums[index]+&#x3D;nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]&gt;&#x3D;2*nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-04-二位数组查找"><a href="#剑指offer-04-二位数组查找" class="headerlink" title="剑指offer 04 二位数组查找"></a>剑指offer 04 二位数组查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">         if ( matrix.size() &#x3D;&#x3D; 0 || matrix[0].size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int rows &#x3D; matrix.size(), coums &#x3D; matrix[0].size();</span><br><span class="line">        int coum &#x3D; coums - 1;</span><br><span class="line">        int row &#x3D; 0;</span><br><span class="line">        while(row&lt;rows&amp;&amp;coum&gt;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(target &#x3D;&#x3D; matrix[row][coum])</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (target &lt; matrix[row][coum])</span><br><span class="line">            &#123;</span><br><span class="line">                coum--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">       string str &#x3D; &quot;%20&quot;;</span><br><span class="line">       while((-1)!&#x3D;s.find(&#39; &#39;) )</span><br><span class="line">       &#123;</span><br><span class="line">           s.replace(s.find(&#39; &#39;),1,str);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-06-打印链表"><a href="#剑指offer-06-打印链表" class="headerlink" title="剑指offer 06 打印链表"></a>剑指offer 06 打印链表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; p;</span><br><span class="line">    while(head)</span><br><span class="line">    &#123;</span><br><span class="line">        p.push_back(head-&gt;val);</span><br><span class="line">        head &#x3D; head-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; m;</span><br><span class="line">    int j;</span><br><span class="line">    for(j&#x3D;p.size()-1; j &gt;&#x3D;0;j-- )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;cout &lt;&lt; p[j] &lt;&lt; endl;</span><br><span class="line">        m.push_back(p[j]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return m;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指offer-07-重建二叉树"><a href="#剑指offer-07-重建二叉树" class="headerlink" title="剑指offer 07 重建二叉树"></a>剑指offer 07 重建二叉树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line"></span><br><span class="line">        if(preorder.empty() || preorder.size() !&#x3D; inorder.size()) return nullptr;</span><br><span class="line">        int preStart &#x3D; 0, inStart &#x3D; 0;</span><br><span class="line">        int preEnd &#x3D; preorder.size() - 1, inEnd &#x3D; inorder.size() - 1;</span><br><span class="line">       </span><br><span class="line">        return binaryTree(preorder, inorder, preStart, preEnd, inStart, inEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *binaryTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int preStart, int preEnd, int inStart, int inEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        if(preStart &gt; preEnd || inStart &gt; inEnd) return nullptr;</span><br><span class="line">        TreeNode *root &#x3D; new TreeNode(preorder[preStart]);</span><br><span class="line">        int middle &#x3D; 0;</span><br><span class="line">        for(auto i : inorder)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i !&#x3D; preorder[preStart]) middle ++;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        root -&gt; left &#x3D; binaryTree(preorder, inorder, preStart+1, preStart+middle-inStart, inStart, middle-1);</span><br><span class="line">        root -&gt; right &#x3D; binaryTree(preorder, inorder, preEnd-(inEnd-middle)+1, preEnd, middle+1, inEnd);</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1592-重新排列2单词间空格"><a href="#1592-重新排列2单词间空格" class="headerlink" title="1592 重新排列2单词间空格"></a>1592 重新排列2单词间空格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reorderSpaces(string text) &#123;</span><br><span class="line"></span><br><span class="line">    using namespace  std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int num &#x3D; 0;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    int sum &#x3D; text.length();  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string str_out &#x3D; &quot;&quot;;</span><br><span class="line">    int jishu[100] &#x3D; &#123;0&#125;;</span><br><span class="line">    string str;</span><br><span class="line">    int flag &#x3D; text.find(&#39; &#39;);</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">   </span><br><span class="line">      while((-1) !&#x3D; flag)</span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">        while(0 &#x3D;&#x3D; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            text.erase(0, 1);</span><br><span class="line">           </span><br><span class="line">            flag &#x3D; text.find(&#39; &#39;);</span><br><span class="line">            if(text.length() &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                jishu[i] &#x3D; text.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        if (flag &gt; 0 )</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            str &#x3D; text.substr(0, flag);</span><br><span class="line">            jishu[i] &#x3D; flag;</span><br><span class="line">            str_out +&#x3D; str;</span><br><span class="line">            text.erase(0, flag);</span><br><span class="line">            i +&#x3D; 1;</span><br><span class="line">            flag &#x3D; text.find(&#39; &#39;);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">    int j &#x3D; 1;</span><br><span class="line">    for (j&#x3D;1; j&lt;&#x3D;i; j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        if(jishu[j] &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        num +&#x3D; jishu[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    int n_s &#x3D; sum - num;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    if( i &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    int sp , rsp;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    if(0 &#x3D;&#x3D; text.length())</span><br><span class="line">    &#123;</span><br><span class="line">        n_s &#x3D; sum -str_out.length() ;</span><br><span class="line">        int n &#x3D;str_out.length()- jishu[i-1];</span><br><span class="line">        text &#x3D; str_out.substr(n, jishu[i-1]);</span><br><span class="line">        i -&#x3D; 1;</span><br><span class="line">        if(i &#x3D;&#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            rsp &#x3D; sum - jishu[1] ;</span><br><span class="line">            string space &#x3D; &quot;&quot;;</span><br><span class="line">            space.append(rsp, &#39; &#39;);</span><br><span class="line">            str_out +&#x3D; space;</span><br><span class="line">            return str_out;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          cout  &lt;&lt; &quot;@&quot; &lt;&lt; str_out.length() &lt;&lt; &quot;@&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">           sp &#x3D; n_s&#x2F;(i-1) ;</span><br><span class="line">    </span><br><span class="line">           rsp &#x3D; n_s -sp *(i-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">       sp &#x3D; n_s&#x2F;(i-1);</span><br><span class="line">    </span><br><span class="line">        rsp &#x3D; n_s -sp *(i-1);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    int s;</span><br><span class="line">    string  space &#x3D; &quot;&quot; ;</span><br><span class="line">    space.append(sp, &#39; &#39;);</span><br><span class="line">    string  rspace &#x3D; &quot;&quot; ;</span><br><span class="line">    rspace.append(rsp, &#39; &#39;);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">      string retu &#x3D; &quot;&quot;;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    for (s &#x3D;1; s&lt; i ; s++)</span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        retu +&#x3D; str_out.substr(0, jishu[s]) +  space;</span><br><span class="line">      </span><br><span class="line">        str_out.erase(0, jishu[s]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">     retu +&#x3D; text ;</span><br><span class="line"></span><br><span class="line">     retu +&#x3D; rspace ; </span><br><span class="line">     </span><br><span class="line">     return retu;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   int rsp &#x3D; sum - text.length();</span><br><span class="line">   string rspace &#x3D; &quot;&quot;;</span><br><span class="line">   rspace.append(rsp, &#39; &#39;);</span><br><span class="line">   text +&#x3D; rspace;</span><br><span class="line">   return text;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1630-等差子数组"><a href="#1630-等差子数组" class="headerlink" title="1630 等差子数组"></a>1630 等差子数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123;</span><br><span class="line">        using namespace std;</span><br><span class="line">        int num_l &#x3D; l.size();</span><br><span class="line">        vector&lt;bool&gt; answer;</span><br><span class="line">        vector&lt;int&gt; p;</span><br><span class="line">        int length,n,j, loss;</span><br><span class="line">        int  idea &#x3D;0;</span><br><span class="line">        for (int i&#x3D;0; i&lt;num_l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for ( j&#x3D;l[i]; j&lt;&#x3D;r[i]; j++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                p.push_back(nums[j]);</span><br><span class="line">               &#x2F;&#x2F; cout &lt;&lt; nums[j] &lt;&lt; endl;</span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sort(p.begin(), p.end());</span><br><span class="line">            length &#x3D; p.size();</span><br><span class="line">             loss &#x3D;abs( p[1] - p[0]);</span><br><span class="line">           </span><br><span class="line">            for ( n&#x3D;1; n&lt;length; n++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (p[n] !&#x3D; (p[n-1]+loss))</span><br><span class="line">                &#123;</span><br><span class="line">                    answer.push_back(false);</span><br><span class="line">                    idea +&#x3D; 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">         </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if (idea &#x3D;&#x3D; i)</span><br><span class="line">        &#123;</span><br><span class="line">            answer.push_back(true);</span><br><span class="line">            idea +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            p.clear();</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        return answer;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="1629-按键持续最长的建"><a href="#1629-按键持续最长的建" class="headerlink" title="1629 按键持续最长的建"></a>1629 按键持续最长的建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) &#123;</span><br><span class="line">        </span><br><span class="line">        int n &#x3D; releaseTimes.size();</span><br><span class="line">            </span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        int time;</span><br><span class="line">        int time_max &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &gt;0)</span><br><span class="line">                time &#x3D; releaseTimes[i] -  releaseTimes[i-1];</span><br><span class="line">            else</span><br><span class="line">                time &#x3D; releaseTimes[i] ;</span><br><span class="line">            if (time &gt;&#x3D; time_max)</span><br><span class="line">            &#123;</span><br><span class="line">                time_max  &#x3D;  time;</span><br><span class="line">                num &#x3D; i;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        return keysPressed[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>mylife</title>
    <url>/posts/c9e3de7b/</url>
    <content><![CDATA[<p><img src="https://gitee.com/liyouran/image/raw/master/a.png"></p>
]]></content>
  </entry>
  <entry>
    <title>letnet_minst</title>
    <url>/posts/574630c2/</url>
    <content><![CDATA[<p>lenet 在minst数据集的测试，主要增加了线性层归一化，测试集准确率为99.1%</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line">import torch.optim as optim</span><br><span class="line">from torchvision import datasets,transforms</span><br><span class="line">import torchvision</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.style.use(&#39;seaborn-white&#39;)</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;Noto Sans CJK JP&#39;] # 用来正常显示中文标签</span><br><span class="line">plt.rcParams[&#39;axes.unicode_minus&#39;]&#x3D;False # 用来正常显示负号</span><br><span class="line"></span><br><span class="line">train_acclist &#x3D; []</span><br><span class="line">test_acclist &#x3D; []</span><br><span class="line">loss_list &#x3D; []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LeNet(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(LeNet, self).__init__()</span><br><span class="line">        self.conv1 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Conv2d(1, 6, 3, 1, 2),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.conv2 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Conv2d(6, 16, 5),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc1 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(16 * 5 * 5, 120),</span><br><span class="line">            nn.BatchNorm1d(120),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc2 &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(120, 84),</span><br><span class="line">            nn.BatchNorm1d(84),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc3 &#x3D; nn.Linear(84, 10)</span><br><span class="line"></span><br><span class="line">    #         self.sfx &#x3D; nn.Softmax()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x &#x3D; self.conv1(x)</span><br><span class="line">        x &#x3D; self.conv2(x)</span><br><span class="line">        #         print(x.shape)</span><br><span class="line">        x &#x3D; x.view(x.size()[0], -1)</span><br><span class="line">        x &#x3D; self.fc1(x)</span><br><span class="line">        x &#x3D; self.fc2(x)</span><br><span class="line">        x &#x3D; self.fc3(x)</span><br><span class="line">        #         x &#x3D; self.sfx(x)</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">device &#x3D; torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)</span><br><span class="line">batch_size &#x3D; 64</span><br><span class="line">LR &#x3D; 0.001</span><br><span class="line">Momentum &#x3D; 0.9</span><br><span class="line"></span><br><span class="line"># 下载数据集</span><br><span class="line">train_dataset &#x3D; datasets.MNIST(root &#x3D; &#39;&#x2F;home&#x2F;liyou&#x2F;my tools&#x2F;myworks&#39;,</span><br><span class="line">                              train&#x3D;True,</span><br><span class="line">                              transform &#x3D; transforms.ToTensor(),</span><br><span class="line">                              download&#x3D;True)</span><br><span class="line">test_dataset &#x3D;datasets.MNIST(root &#x3D; &#39;&#x2F;home&#x2F;liyou&#x2F;my tools&#x2F;myworks&#x2F;&#39;,</span><br><span class="line">                            train&#x3D;False,</span><br><span class="line">                            transform&#x3D;transforms.ToTensor(),</span><br><span class="line">                            download&#x3D;True)</span><br><span class="line">#建立一个数据迭代器</span><br><span class="line">train_loader &#x3D; torch.utils.data.DataLoader(dataset &#x3D; train_dataset,</span><br><span class="line">                                          batch_size &#x3D; batch_size,</span><br><span class="line">                                          shuffle &#x3D; True)</span><br><span class="line">test_loader &#x3D; torch.utils.data.DataLoader(dataset &#x3D; test_dataset,</span><br><span class="line">                                         batch_size &#x3D; batch_size,</span><br><span class="line">                                         shuffle &#x3D; False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def evaluate_accuracy(data_iter, net, device&#x3D;None):</span><br><span class="line">    if device is None and isinstance(net, torch.nn.Module):</span><br><span class="line">        # 如果没指定device就使用net的device</span><br><span class="line">        device &#x3D; list(net.parameters())[0].device</span><br><span class="line">    acc_sum, n &#x3D; 0.0, 0</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        for X, y in data_iter:</span><br><span class="line">            X &#x3D; X.to(device)</span><br><span class="line">            y &#x3D; y.to(device)</span><br><span class="line">            if isinstance(net, torch.nn.Module):</span><br><span class="line">                net.eval() # 评估模式, 这会关闭dropout</span><br><span class="line">                acc_sum +&#x3D; (net(X).argmax(dim&#x3D;1) &#x3D;&#x3D; y).float().sum().cpu().item()</span><br><span class="line">                net.train() # 改回训练模式</span><br><span class="line">            n +&#x3D; y.shape[0]</span><br><span class="line">    return acc_sum &#x2F; n</span><br><span class="line"></span><br><span class="line">def train_lenet(num_epochs, net, optimizer):</span><br><span class="line">    net &#x3D; net.to(device)</span><br><span class="line">    print(&quot;training on &quot;, device)</span><br><span class="line">    loss &#x3D; torch.nn.CrossEntropyLoss()</span><br><span class="line">    for epoch in range(num_epochs):</span><br><span class="line">        train_l_sum, train_acc_sum, n, batch_count, start &#x3D; 0.0, 0.0, 0, 0, time.time()</span><br><span class="line">        for X, y in train_loader:</span><br><span class="line">            X &#x3D; X.to(device)</span><br><span class="line">            y &#x3D; y.to(device)</span><br><span class="line">            y_hat &#x3D; net(X)</span><br><span class="line">            l &#x3D; loss(y_hat, y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            train_l_sum +&#x3D; l.cpu().item()</span><br><span class="line">            train_acc_sum +&#x3D; (y_hat.argmax(dim&#x3D;1) &#x3D;&#x3D; y).sum().cpu().item()</span><br><span class="line">            n +&#x3D; y.shape[0]</span><br><span class="line">            batch_count +&#x3D; 1</span><br><span class="line">        test_acc &#x3D; evaluate_accuracy(test_loader, net)</span><br><span class="line">        print(&#39;epoch %d, loss %.4f, train acc %.3f, test acc %.3f, time %.1f sec&#39;</span><br><span class="line">                % (epoch + 1, train_l_sum &#x2F; batch_count, train_acc_sum &#x2F; n, test_acc, time.time() - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        loss_list.append(train_l_sum &#x2F; batch_count)</span><br><span class="line">        train_acclist.append(train_acc_sum &#x2F; n)</span><br><span class="line">        test_acclist.append(test_acc)</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    net &#x3D; LeNet().to(device)</span><br><span class="line">    optimizer &#x3D; optim.SGD(net.parameters(),lr&#x3D;LR,momentum&#x3D;Momentum)</span><br><span class="line">    epoch &#x3D; 50</span><br><span class="line"></span><br><span class="line">    train_lenet(epoch, net, optimizer)</span><br><span class="line">    x &#x3D; np.arange(epoch)</span><br><span class="line">    fig, ax &#x3D; plt.subplots(1, 3,figsize &#x3D; (16, 3))</span><br><span class="line">  </span><br><span class="line">    ax[0].plot(x, loss_list)</span><br><span class="line">    ax[0].set_title(&quot;loss&quot;)</span><br><span class="line">    ax[1].plot(x, train_acclist)</span><br><span class="line">    ax[1].set_title(u&quot;训练集准确性&quot;)</span><br><span class="line"></span><br><span class="line">    ax[2].plot(x, test_acclist)</span><br><span class="line">    ax[2].set_title(u&quot;测试集准确性&quot;)</span><br><span class="line">    plt.savefig(&#39;.&#x2F;image&#x2F;image_m&#39;)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # x, y &#x3D; train_dataset[0]</span><br><span class="line">    # print(x.size())</span><br><span class="line">    # print(y)</span><br><span class="line"></span><br><span class="line">    # for i in range(10):</span><br><span class="line">    #       image_array,_&#x3D;train_dataset[i]#打印第i个</span><br><span class="line">    #       image_array&#x3D;image_array.resize(28,28)</span><br><span class="line">     </span><br><span class="line">    #       print(train_dataset.train_labels[i])#打印出标签</span><br><span class="line">    #       plt.imshow(image_array)</span><br><span class="line">    #       plt.savefig(&#39;.&#x2F;image&#x2F;image[%d]&#39;%(i))</span><br><span class="line">    #       plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>nvida_+cuda配置</title>
    <url>/posts/8c814bdb/</url>
    <content><![CDATA[<p>ubuntu18.04<br>配置环境：nvidia 、 cuda10.1</p>
<a id="more"></a>

<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>添加ppa源无反应或超时，更新软件源显示无公匙， 添加秘匙， 更新软件源，有概率ppa源添加成功；如果软件源更新进度为0，将默认通道由ipv6改为ipv</p>
<p>安装cuda包，驱动貌似并未集成，若单独安装cuda工具包没有问题， 如果一起安装会失败，下次有时间记得查一下</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>开发环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread多线程矩阵运算</title>
    <url>/posts/12c87f1c/</url>
    <content><![CDATA[<h2 id="多线程进行矩阵运算"><a href="#多线程进行矩阵运算" class="headerlink" title="多线程进行矩阵运算"></a>多线程进行矩阵运算</h2><p>主要为定义二级指针，实现动态二位数组以及随机赋值，但是存在线程数组无法动态赋值的问题</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;chrono&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace chrono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_mutex_t  g_mutex_lock;</span><br><span class="line">int l &#x3D; 0;</span><br><span class="line">int arry_num[4] &#x3D; &#123;48, 128,1024, 2024&#125;;</span><br><span class="line">int threads_num[4] &#x3D; &#123;1, 2, 4, 8 &#125;;</span><br><span class="line">int threads &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> unsigned long timer;</span><br><span class="line"></span><br><span class="line">int **a                                                                      ;</span><br><span class="line">int **b;</span><br><span class="line">int **c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void arry_fuzhi();</span><br><span class="line">void * THread(void * data);</span><br><span class="line">void threads_j(int j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> for(int i&#x3D;0; i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l &#x3D; arry_num[i];</span><br><span class="line">        arry_fuzhi(); </span><br><span class="line">         for (int j&#x3D; 0; j&lt;4;j++)</span><br><span class="line">            threads_j(threads_num[3]);</span><br><span class="line">           </span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    delete [] a;</span><br><span class="line">    delete [] b;</span><br><span class="line">    delete [] c;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi()</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; new int * [l];</span><br><span class="line">    b &#x3D; new int * [l];                                                          </span><br><span class="line">    c &#x3D; new int * [l];</span><br><span class="line">    for (int i&#x3D;0; i&lt;l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] &#x3D; new int[l];</span><br><span class="line">        b[i] &#x3D; new int[l];</span><br><span class="line">        c[i] &#x3D; new int[l];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int n&#x3D;0; n&lt;l; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m&#x3D;0; m&lt;l; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n][m] &#x3D; rand() % 100;</span><br><span class="line">            b[n][m] &#x3D; rand() % 100;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * THread(void *data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int i, j, k, tid, portin_size, row_start, row_end;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    tid &#x3D; *(int *)data ;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    portin_size &#x3D; l &#x2F; threads;</span><br><span class="line">    row_start &#x3D; tid * portin_size;</span><br><span class="line">    </span><br><span class="line">    row_end &#x3D; (tid+1) * portin_size;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;row_start; i&lt;row_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       for (int k&#x3D;0; k&lt;l; k++)</span><br><span class="line">       &#123;</span><br><span class="line">        for(int j&#x3D;0; j&lt;l; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i][j] * b[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        c[i][k] &#x3D; sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void threads_j(int j)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; timeval  start_t;</span><br><span class="line">            &#x2F;&#x2F; timeval  end_t;</span><br><span class="line">            timeval  start;</span><br><span class="line">            timeval  end;</span><br><span class="line">            threads &#x3D; j;</span><br><span class="line">            &#x2F;&#x2F;gettimeofday(&amp;start_t, NULL);</span><br><span class="line">            gettimeofday(&amp;start, NULL);</span><br><span class="line">            pthread_t  *pid  &#x3D; new pthread_t [j];</span><br><span class="line"></span><br><span class="line">            for(int num&#x3D;0; num&lt;j; num++)</span><br><span class="line">            &#123;</span><br><span class="line">            pthread_create(&amp;pid[num], NULL, THread,  &amp;num);</span><br><span class="line">            pthread_join(pid[num], NULL);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">           &#x2F;&#x2F; gettimeofday(&amp;end_t, NULL);</span><br><span class="line">            gettimeofday(&amp;end, NULL);</span><br><span class="line">           &#x2F;&#x2F; timer &#x3D; 1000000*(end_t.tv_sec-start_t.tv_sec)+ end_t.tv_usec-start_t.tv_usec;&#x2F;&#x2F;微秒计时</span><br><span class="line">            &#x2F;&#x2F;cout &lt;&lt;  double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den  &lt;&lt; endl;</span><br><span class="line">            timer &#x3D;1000000* (end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec;&#x2F;&#x2F;多线程计算时间（微秒）</span><br><span class="line">             cout &lt;&lt; &quot;线程设为:&quot; &lt;&lt;  endl;</span><br><span class="line">             cout  &lt;&lt;  &quot;多线程完成矩阵运算的时间为：&quot;  ; </span><br><span class="line">             cout &lt;&lt;timer &lt;&lt;  &quot;微秒&quot;  &lt;&lt; endl;</span><br><span class="line">            delete [] pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高性能</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程矩阵运算</title>
    <url>/posts/dd0dc916/</url>
    <content><![CDATA[<p>多线程矩阵运算</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;chrono&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace chrono;</span><br><span class="line"> int  l &#x3D; 0;</span><br><span class="line"> int threads_j &#x3D; 4;</span><br><span class="line">  double t;</span><br><span class="line">int arry_num[4] &#x3D; &#123;128, 256, 512, 1024&#125;;</span><br><span class="line">int **a ;</span><br><span class="line">int **b;</span><br><span class="line">int **c;</span><br><span class="line"></span><br><span class="line">void singel_worker();</span><br><span class="line">pthread_t  *pid ;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi();</span><br><span class="line">void * THread(void * data);</span><br><span class="line">void threads_time();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int a_num&#x3D;0; a_num&lt;4; a_num++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        l &#x3D; arry_num[a_num];</span><br><span class="line">        arry_fuzhi();</span><br><span class="line">        cout &lt;&lt; &quot;\n矩阵阶数：&quot; &lt;&lt; l &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        auto start1 &#x3D; system_clock::now();</span><br><span class="line">        singel_worker();</span><br><span class="line">        auto end1 &#x3D; system_clock::now();</span><br><span class="line"></span><br><span class="line">        auto duration1 &#x3D; duration_cast&lt;microseconds&gt;(end1 - start1);</span><br><span class="line">         t &#x3D; double(duration1.count()) * microseconds::period::num &#x2F; microseconds::period::den;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; &quot;单线程花费了: &quot; &lt;&lt;  t  &lt;&lt; &quot;秒&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        while (threads_j &lt; 17)</span><br><span class="line">        &#123;</span><br><span class="line">           threads_time();</span><br><span class="line">            threads_j +&#x3D; 4;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        threads_j &#x3D; 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete [] a;</span><br><span class="line">    delete [] b;</span><br><span class="line">    delete [] c;</span><br><span class="line">    delete [] pid;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi()</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; new int * [l];</span><br><span class="line">    b &#x3D; new int * [l];                                                          </span><br><span class="line">    c &#x3D; new int * [l];</span><br><span class="line">    for (int i&#x3D;0; i&lt;l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] &#x3D; new int[l];</span><br><span class="line">        b[i] &#x3D; new int[l];</span><br><span class="line">        c[i] &#x3D; new int[l];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   for (int n&#x3D;0; n&lt;l; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m&#x3D;0; m&lt;l; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n][m] &#x3D; double(rand()%100);</span><br><span class="line">            b[n][m] &#x3D; double(rand()%100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * THread(void *data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int i, j, k, tid, portin_size, row_start, row_end;</span><br><span class="line">    double  sum &#x3D; 0;</span><br><span class="line">    tid &#x3D; *(int *)data ;</span><br><span class="line"> </span><br><span class="line">    portin_size &#x3D; l &#x2F; threads_j;</span><br><span class="line">    row_start &#x3D; tid * portin_size;</span><br><span class="line">    </span><br><span class="line">    row_end &#x3D; (tid+1) * portin_size;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;row_start; i&lt;row_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       for (int k&#x3D;0; k&lt;l; k++)</span><br><span class="line">       &#123;</span><br><span class="line">        for(int j&#x3D;0; j&lt;l; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i][j] * b[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        c[i][k] &#x3D; sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void singel_worker() &#123;</span><br><span class="line">    double sum;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; l; ++i)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; l; ++j) &#123;  &#x2F;&#x2F; hold column index of &#39;matrix2&#39;</span><br><span class="line">            sum &#x3D; 0;                  &#x2F;&#x2F; hold value of a cell</span><br><span class="line">            for (int k &#x3D; 0; k &lt; l; ++k) &#123;</span><br><span class="line">                sum +&#x3D; a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">           c[i][j] &#x3D; sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threads_time()&#123;</span><br><span class="line">           int num_pth;</span><br><span class="line">            auto start &#x3D; system_clock::now();</span><br><span class="line">            pid &#x3D; new pthread_t[threads_j];</span><br><span class="line"></span><br><span class="line">            for (num_pth &#x3D; 0; num_pth &lt; threads_j; num_pth++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                pthread_create(&amp;pid[num_pth], NULL, THread, &amp;num_pth);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (num_pth &#x3D; 0; num_pth &lt; threads_j; num_pth++)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_join(pid[num_pth], NULL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            auto end &#x3D; system_clock::now();</span><br><span class="line">            auto duration &#x3D; duration_cast&lt;microseconds&gt;(end - start);</span><br><span class="line">            double t1 &#x3D; double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den;</span><br><span class="line">            double  tt &#x3D; t&#x2F;t1;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; &quot;多线程设为: &quot; &lt;&lt; threads_j &lt;&lt;  &quot;线程&quot; &lt;&lt;  endl;</span><br><span class="line">            cout &lt;&lt; &quot;花费了&quot;</span><br><span class="line">                 &lt;&lt; double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den</span><br><span class="line">                 &lt;&lt; &quot;秒&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; &quot;加速比为：&quot; &lt;&lt;  tt   &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>多线程矩阵运算</tag>
      </tags>
  </entry>
</search>
