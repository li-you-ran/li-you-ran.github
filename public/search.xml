<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubutu桌面不显示</title>
    <url>/posts/c66da4c6/</url>
    <content><![CDATA[<h2><span id="ubuntu-桌面不显示文件">ubuntu 桌面不显示文件</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">win + tab</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2><span id="ubuntu-输入法间隔变大">ubuntu 输入法间隔变大</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">shift + space</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署在gitee可能出现问题</title>
    <url>/posts/5237292d/</url>
    <content><![CDATA[<h2><span id="gitee-静态页面强制">gitee  静态页面强制</span></h2><a id="more"></a>

<p>将hexo部署到gitee后，本地可以更新，浏览器访问必须强制刷新,清除浏览器缓存后更新，否则一直调用本地缓存，并且第一次登入图标加载也会有点问题。</p>
<p><strong>将hexo部署到github并未发生这种问题</strong></p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>-gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>mylife</title>
    <url>/posts/c9e3de7b/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pthread多线程矩阵运算</title>
    <url>/posts/12c87f1c/</url>
    <content><![CDATA[<h2><span id="多线程进行矩阵运算">多线程进行矩阵运算</span></h2><p>主要为定义二级指针，实现动态二位数组以及随机赋值，但是存在线程数组无法动态赋值的问题</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;chrono&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace chrono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_mutex_t  g_mutex_lock;</span><br><span class="line">int l &#x3D; 0;</span><br><span class="line">int arry_num[4] &#x3D; &#123;48, 128,1024, 2024&#125;;</span><br><span class="line">int threads_num[4] &#x3D; &#123;1, 2, 4, 8 &#125;;</span><br><span class="line">int threads &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> unsigned long timer;</span><br><span class="line"></span><br><span class="line">int **a                                                                      ;</span><br><span class="line">int **b;</span><br><span class="line">int **c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void arry_fuzhi();</span><br><span class="line">void * THread(void * data);</span><br><span class="line">void threads_j(int j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> for(int i&#x3D;0; i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l &#x3D; arry_num[i];</span><br><span class="line">        arry_fuzhi(); </span><br><span class="line">         for (int j&#x3D; 0; j&lt;4;j++)</span><br><span class="line">            threads_j(threads_num[3]);</span><br><span class="line">           </span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    delete [] a;</span><br><span class="line">    delete [] b;</span><br><span class="line">    delete [] c;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi()</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; new int * [l];</span><br><span class="line">    b &#x3D; new int * [l];                                                          </span><br><span class="line">    c &#x3D; new int * [l];</span><br><span class="line">    for (int i&#x3D;0; i&lt;l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] &#x3D; new int[l];</span><br><span class="line">        b[i] &#x3D; new int[l];</span><br><span class="line">        c[i] &#x3D; new int[l];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int n&#x3D;0; n&lt;l; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m&#x3D;0; m&lt;l; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n][m] &#x3D; rand() % 100;</span><br><span class="line">            b[n][m] &#x3D; rand() % 100;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * THread(void *data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int i, j, k, tid, portin_size, row_start, row_end;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    tid &#x3D; *(int *)data ;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    portin_size &#x3D; l &#x2F; threads;</span><br><span class="line">    row_start &#x3D; tid * portin_size;</span><br><span class="line">    </span><br><span class="line">    row_end &#x3D; (tid+1) * portin_size;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;row_start; i&lt;row_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       for (int k&#x3D;0; k&lt;l; k++)</span><br><span class="line">       &#123;</span><br><span class="line">        for(int j&#x3D;0; j&lt;l; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i][j] * b[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        c[i][k] &#x3D; sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void threads_j(int j)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; timeval  start_t;</span><br><span class="line">            &#x2F;&#x2F; timeval  end_t;</span><br><span class="line">            timeval  start;</span><br><span class="line">            timeval  end;</span><br><span class="line">            threads &#x3D; j;</span><br><span class="line">            &#x2F;&#x2F;gettimeofday(&amp;start_t, NULL);</span><br><span class="line">            gettimeofday(&amp;start, NULL);</span><br><span class="line">            pthread_t  *pid  &#x3D; new pthread_t [j];</span><br><span class="line"></span><br><span class="line">            for(int num&#x3D;0; num&lt;j; num++)</span><br><span class="line">            &#123;</span><br><span class="line">            pthread_create(&amp;pid[num], NULL, THread,  &amp;num);</span><br><span class="line">            pthread_join(pid[num], NULL);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">           &#x2F;&#x2F; gettimeofday(&amp;end_t, NULL);</span><br><span class="line">            gettimeofday(&amp;end, NULL);</span><br><span class="line">           &#x2F;&#x2F; timer &#x3D; 1000000*(end_t.tv_sec-start_t.tv_sec)+ end_t.tv_usec-start_t.tv_usec;&#x2F;&#x2F;微秒计时</span><br><span class="line">            &#x2F;&#x2F;cout &lt;&lt;  double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den  &lt;&lt; endl;</span><br><span class="line">            timer &#x3D;1000000* (end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec;&#x2F;&#x2F;多线程计算时间（微秒）</span><br><span class="line">             cout &lt;&lt; &quot;线程设为:&quot; &lt;&lt;  endl;</span><br><span class="line">             cout  &lt;&lt;  &quot;多线程完成矩阵运算的时间为：&quot;  ; </span><br><span class="line">             cout &lt;&lt;timer &lt;&lt;  &quot;微秒&quot;  &lt;&lt; endl;</span><br><span class="line">            delete [] pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高性能</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>给老潘</title>
    <url>/posts/55569e20/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t  g_mutex_lock;</span><br><span class="line">int g_cout &#x3D;0;</span><br><span class="line"></span><br><span class="line">void * Thread_g(void * date);</span><br><span class="line"></span><br><span class="line">void * Thread_g(void *date)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;g_mutex_lock);</span><br><span class="line">    g_cout ++;</span><br><span class="line">    pthread_mutex_unlock(&amp;g_mutex_lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;g_cout 的初始值为：&quot; &lt;&lt; g_cout &lt;&lt; endl;</span><br><span class="line">    int i;</span><br><span class="line">    for (i&#x3D;2; i&lt;50; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_t pid[i];</span><br><span class="line">        for (int j&#x3D;0; j&lt;i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pid[j], NULL, Thread_g, NULL);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int n&#x3D;0; n&lt;i; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_join(pid[n], NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;启用了&quot; &lt;&lt; i &lt;&lt; &quot;个线程对g_cout进行累加： &quot; &lt;&lt; endl;</span><br><span class="line">        cout  &lt;&lt; &quot;累加后g_cout 的值为 &quot; &lt;&lt;  g_cout &lt;&lt; endl;</span><br><span class="line">        g_cout  &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std::chrono;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int size &#x3D; 1000;</span><br><span class="line">const int num_threads &#x3D; 16;</span><br><span class="line"></span><br><span class="line">double matrix1[size][size] &#x3D; &#123;0&#125;;</span><br><span class="line">double matrix2[size][size] &#x3D; &#123;0&#125;;</span><br><span class="line">double matrix3[size][size] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *worker(void *arg) &#123;</span><br><span class="line">    int i, j, k, tid, portion_size, row_start, row_end;</span><br><span class="line">    double sum;</span><br><span class="line">    tid &#x3D; *(int *)(arg);  &#x2F;&#x2F; get the thread ID assigned sequentially.</span><br><span class="line">    portion_size &#x3D; size &#x2F; num_threads;</span><br><span class="line">    row_start &#x3D; tid * portion_size;</span><br><span class="line">    row_end &#x3D; (tid + 1) * portion_size;</span><br><span class="line">    for (i &#x3D; row_start; i &lt; row_end; ++i) &#123;  &#x2F;&#x2F; hold row index of &#39;matrix1&#39;</span><br><span class="line">        for (j &#x3D; 0; j &lt; size; ++j) &#123;         &#x2F;&#x2F; hold column index of &#39;matrix2&#39;</span><br><span class="line">            sum &#x3D; 0;                         &#x2F;&#x2F; hold value of a cell</span><br><span class="line">            for (k &#x3D; 0; k &lt; size; ++k) &#123;</span><br><span class="line">                sum +&#x3D; matrix1[i][k] * matrix2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            matrix3[i][j] &#x3D; sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void singel_worker() &#123;</span><br><span class="line">    int i, j, k, tid, portion_size, row_start, row_end;</span><br><span class="line">    double sum;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; size; ++i)</span><br><span class="line">        for (j &#x3D; 0; j &lt; size; ++j) &#123;  &#x2F;&#x2F; hold column index of &#39;matrix2&#39;</span><br><span class="line">            sum &#x3D; 0;                  &#x2F;&#x2F; hold value of a cell</span><br><span class="line">            for (k &#x3D; 0; k &lt; size; ++k) &#123;</span><br><span class="line">                sum +&#x3D; matrix1[i][k] * matrix2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            matrix3[i][j] &#x3D; sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MatrixMultiply() &#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    double sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; size; ++i) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; size; ++j) &#123;</span><br><span class="line">            sum &#x3D; 0;</span><br><span class="line">            for (k &#x3D; 0; k &lt; size; ++k) &#123;</span><br><span class="line">                sum +&#x3D; matrix1[i][k] * matrix2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            matrix3[i][j] &#x3D; sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_t tid[num_threads];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;矩阵大小： &quot; &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    auto start &#x3D; steady_clock::now();</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">        pthread_create(&amp;tid[i], NULL, worker, &amp;i);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; num_threads; i++) &#123;</span><br><span class="line">        pthread_join(tid[i], NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    auto end &#x3D; steady_clock::now();</span><br><span class="line">    auto tt1 &#x3D; duration_cast&lt;milliseconds&gt;(end - start);</span><br><span class="line">    cout &lt;&lt; &quot;多线程数： &quot; &lt;&lt; num_threads &lt;&lt; &quot;    &quot;</span><br><span class="line">         &lt;&lt; &quot;运行时间： &quot; &lt;&lt; tt1.count() &lt;&lt; &quot;ms&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    start &#x3D; steady_clock::now();</span><br><span class="line">    singel_worker();</span><br><span class="line">    end &#x3D; steady_clock::now();</span><br><span class="line">    auto tt2 &#x3D; duration_cast&lt;milliseconds&gt;(end - start);</span><br><span class="line">    cout &lt;&lt; &quot;单线程运行时间： &quot; &lt;&lt; tt2.count() &lt;&lt; &quot;ms&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;加速比： &quot; &lt;&lt; (double)(tt2.count()&#x2F;tt1.count()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
