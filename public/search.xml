<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubutu桌面不显示</title>
    <url>/posts/c66da4c6/</url>
    <content><![CDATA[<h2><span id="ubuntu-桌面不显示文件">ubuntu 桌面不显示文件</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">win + tab</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2><span id="ubuntu-输入法间隔变大">ubuntu 输入法间隔变大</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用快捷键</span><br><span class="line">shift + space</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署在gitee可能出现问题</title>
    <url>/posts/5237292d/</url>
    <content><![CDATA[<h2><span id="gitee-静态页面强制">gitee  静态页面强制</span></h2><a id="more"></a>

<p>将hexo部署到gitee后，本地可以更新，浏览器访问必须强制刷新,清除浏览器缓存后更新，否则一直调用本地缓存，并且第一次登入图标加载也会有点问题。</p>
<p><strong>将hexo部署到github并未发生这种问题</strong></p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>-gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>mylife</title>
    <url>/posts/c9e3de7b/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pthread多线程矩阵运算</title>
    <url>/posts/12c87f1c/</url>
    <content><![CDATA[<h2><span id="多线程进行矩阵运算">多线程进行矩阵运算</span></h2><p>主要为定义二级指针，实现动态二位数组以及随机赋值，但是存在线程数组无法动态赋值的问题</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;chrono&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace chrono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_mutex_t  g_mutex_lock;</span><br><span class="line">int l &#x3D; 0;</span><br><span class="line">int arry_num[4] &#x3D; &#123;48, 128,1024, 2024&#125;;</span><br><span class="line">int threads_num[4] &#x3D; &#123;1, 2, 4, 8 &#125;;</span><br><span class="line">int threads &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> unsigned long timer;</span><br><span class="line"></span><br><span class="line">int **a                                                                      ;</span><br><span class="line">int **b;</span><br><span class="line">int **c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void arry_fuzhi();</span><br><span class="line">void * THread(void * data);</span><br><span class="line">void threads_j(int j);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> for(int i&#x3D;0; i&lt;4;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l &#x3D; arry_num[i];</span><br><span class="line">        arry_fuzhi(); </span><br><span class="line">         for (int j&#x3D; 0; j&lt;4;j++)</span><br><span class="line">            threads_j(threads_num[3]);</span><br><span class="line">           </span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    delete [] a;</span><br><span class="line">    delete [] b;</span><br><span class="line">    delete [] c;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void arry_fuzhi()</span><br><span class="line">&#123;</span><br><span class="line">    a &#x3D; new int * [l];</span><br><span class="line">    b &#x3D; new int * [l];                                                          </span><br><span class="line">    c &#x3D; new int * [l];</span><br><span class="line">    for (int i&#x3D;0; i&lt;l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] &#x3D; new int[l];</span><br><span class="line">        b[i] &#x3D; new int[l];</span><br><span class="line">        c[i] &#x3D; new int[l];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int n&#x3D;0; n&lt;l; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m&#x3D;0; m&lt;l; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n][m] &#x3D; rand() % 100;</span><br><span class="line">            b[n][m] &#x3D; rand() % 100;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void * THread(void *data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int i, j, k, tid, portin_size, row_start, row_end;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    tid &#x3D; *(int *)data ;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;cout &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">    portin_size &#x3D; l &#x2F; threads;</span><br><span class="line">    row_start &#x3D; tid * portin_size;</span><br><span class="line">    </span><br><span class="line">    row_end &#x3D; (tid+1) * portin_size;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;row_start; i&lt;row_end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">       for (int k&#x3D;0; k&lt;l; k++)</span><br><span class="line">       &#123;</span><br><span class="line">        for(int j&#x3D;0; j&lt;l; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i][j] * b[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        c[i][k] &#x3D; sum;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void threads_j(int j)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; timeval  start_t;</span><br><span class="line">            &#x2F;&#x2F; timeval  end_t;</span><br><span class="line">            timeval  start;</span><br><span class="line">            timeval  end;</span><br><span class="line">            threads &#x3D; j;</span><br><span class="line">            &#x2F;&#x2F;gettimeofday(&amp;start_t, NULL);</span><br><span class="line">            gettimeofday(&amp;start, NULL);</span><br><span class="line">            pthread_t  *pid  &#x3D; new pthread_t [j];</span><br><span class="line"></span><br><span class="line">            for(int num&#x3D;0; num&lt;j; num++)</span><br><span class="line">            &#123;</span><br><span class="line">            pthread_create(&amp;pid[num], NULL, THread,  &amp;num);</span><br><span class="line">            pthread_join(pid[num], NULL);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">           &#x2F;&#x2F; gettimeofday(&amp;end_t, NULL);</span><br><span class="line">            gettimeofday(&amp;end, NULL);</span><br><span class="line">           &#x2F;&#x2F; timer &#x3D; 1000000*(end_t.tv_sec-start_t.tv_sec)+ end_t.tv_usec-start_t.tv_usec;&#x2F;&#x2F;微秒计时</span><br><span class="line">            &#x2F;&#x2F;cout &lt;&lt;  double(duration.count()) * microseconds::period::num &#x2F; microseconds::period::den  &lt;&lt; endl;</span><br><span class="line">            timer &#x3D;1000000* (end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec;&#x2F;&#x2F;多线程计算时间（微秒）</span><br><span class="line">             cout &lt;&lt; &quot;线程设为:&quot; &lt;&lt;  endl;</span><br><span class="line">             cout  &lt;&lt;  &quot;多线程完成矩阵运算的时间为：&quot;  ; </span><br><span class="line">             cout &lt;&lt;timer &lt;&lt;  &quot;微秒&quot;  &lt;&lt; endl;</span><br><span class="line">            delete [] pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高性能</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
